// SPDX-License-Identifier: GPL-2.0
/*
 * Raydium RM67199 MIPI-DSI panel driver
 *
 * Copyright (c) 2023 FriendlyElec Computer Tech. Co., Ltd.
 * (http://www.friendlyelec.com)
 *
 * Copyright 2019 NXP
 */

#include <drm/drm_mipi_dsi.h>

#include <config.h>
#include <common.h>
#include <errno.h>
#include <malloc.h>
#include <video.h>
#include <backlight.h>
#include <asm/gpio.h>
#include <dm/device.h>
#include <dm/read.h>
#include <dm/uclass.h>
#include <dm/uclass-id.h>
#include <linux/media-bus-format.h>
#include <power/regulator.h>

#include "rockchip_display.h"
#include "rockchip_crtc.h"
#include "rockchip_connector.h"
#include "rockchip_panel.h"

/* Panel specific color-format bits */
#define COL_FMT_16BPP 0x55
#define COL_FMT_18BPP 0x66
#define COL_FMT_24BPP 0x77

/* Write Manufacture Command Set Control */
#define WRMAUCCTR 0xFE

/* Manufacturer Command Set pages (CMD2) */
struct cmd_set_entry {
	u8 cmd;
	u8 param;
};

/*
 * There is no description in the Reference Manual about these commands.
 * We received them from vendor, so just use them as is.
 */
static const struct cmd_set_entry mcs_zh055oe[] = {
	{0xFE, 0xA0}, {0x2B, 0x18}, {0xFE, 0x70}, {0x7D, 0x35},
	{0x5D, 0x0A}, {0x5A, 0x79}, {0x5C, 0x00}, {0x52, 0x00},
	{0xFE, 0xD0}, {0x40, 0x02}, {0x13, 0x40}, {0xFE, 0x40},
	{0x05, 0x08}, {0x06, 0x08}, {0x08, 0x08}, {0x09, 0x08},
	{0x0A, 0xCA}, {0x0B, 0x88}, {0x20, 0x93}, {0x21, 0x93},
	{0x24, 0x02}, {0x26, 0x02}, {0x28, 0x05}, {0x2A, 0x05},
	{0x74, 0x2F}, {0x75, 0x1E}, {0xAD, 0x00}, {0xFE, 0x50},
	{0xDA, 0x01}, {0x44, 0x05}, {0x42, 0x05}, {0x40, 0x05},
	{0x3A, 0x05}, {0x38, 0x05}, {0x36, 0x05}, {0x34, 0x05},
	{0x32, 0x05}, {0x30, 0x05}, {0x2A, 0x05}, {0x28, 0x05},
	{0x26, 0x04}, {0x24, 0x04}, {0x22, 0x04}, {0x20, 0x04},
	{0x1E, 0x04}, {0x1C, 0x04}, {0x1A, 0x04}, {0x18, 0x03},
	{0x16, 0x03}, {0x14, 0x03}, {0x12, 0x03}, {0x10, 0x03},
	{0x0E, 0x03}, {0x0C, 0x03}, {0x0A, 0x02}, {0x08, 0x02},
	{0x06, 0x02}, {0x04, 0x02}, {0x02, 0x03}, {0xD0, 0x02},
	{0xCE, 0x02}, {0x00, 0x00}, {0x45, 0xA7}, {0x43, 0xA0},
	{0x41, 0x99}, {0x3B, 0x8C}, {0x39, 0x80}, {0x37, 0x6A},
	{0x35, 0x54}, {0x33, 0x3F}, {0x31, 0x2A}, {0x2B, 0x15},
	{0x29, 0x01}, {0x27, 0xED}, {0x25, 0xD9}, {0x23, 0xB0},
	{0x21, 0x89}, {0x1F, 0x62}, {0x1D, 0x3A}, {0x1B, 0x11},
	{0x19, 0xE9}, {0x17, 0xBF}, {0x15, 0x8B}, {0x13, 0x71},
	{0x11, 0x56}, {0x0F, 0x34}, {0x0D, 0x0E}, {0x0B, 0xF5},
	{0x09, 0xD9}, {0x07, 0xB8}, {0x05, 0x8F}, {0x03, 0x5E},
	{0xD1, 0x7E}, {0xCF, 0x76}, {0x01, 0x00}, {0x86, 0x05},
	{0x84, 0x05}, {0x82, 0x05}, {0x80, 0x05}, {0x7E, 0x05},
	{0x7C, 0x05}, {0x7A, 0x05}, {0x78, 0x05}, {0x76, 0x05},
	{0x74, 0x05}, {0x72, 0x05}, {0x70, 0x04}, {0x6E, 0x04},
	{0x6C, 0x04}, {0x6A, 0x04}, {0x68, 0x04}, {0x66, 0x04},
	{0x64, 0x04}, {0x62, 0x03}, {0x60, 0x03}, {0x5E, 0x03},
	{0x5C, 0x03}, {0x5A, 0x03}, {0x58, 0x03}, {0x52, 0x03},
	{0x50, 0x02}, {0x4E, 0x02}, {0x4C, 0x02}, {0x4A, 0x02},
	{0x48, 0x03}, {0xD4, 0x02}, {0xD2, 0x02}, {0x46, 0x00},
	{0x87, 0xAC}, {0x85, 0xA9}, {0x83, 0xA3}, {0x81, 0x96},
	{0x7F, 0x8A}, {0x7D, 0x74}, {0x7B, 0x5E}, {0x79, 0x49},
	{0x77, 0x34}, {0x75, 0x1F}, {0x73, 0x0B}, {0x71, 0xF7},
	{0x6F, 0xE3}, {0x6D, 0xBB}, {0x6B, 0x93}, {0x69, 0x6B},
	{0x67, 0x42}, {0x65, 0x1A}, {0x63, 0xF1}, {0x61, 0xC6},
	{0x5F, 0x91}, {0x5D, 0x76}, {0x5B, 0x5B}, {0x59, 0x39},
	{0x53, 0x12}, {0x51, 0xF9}, {0x4F, 0xDD}, {0x4D, 0xBC},
	{0x4B, 0x93}, {0x49, 0x63}, {0xD5, 0x83}, {0xD3, 0x7B},
	{0x47, 0x00}, {0xCC, 0x06}, {0xCA, 0x06}, {0xC8, 0x06},
	{0xC6, 0x06}, {0xC4, 0x06}, {0xC2, 0x06}, {0xC0, 0x06},
	{0xBE, 0x06}, {0xBC, 0x05}, {0xBA, 0x05}, {0xB8, 0x05},
	{0xB6, 0x05}, {0xB4, 0x05}, {0xB2, 0x05}, {0xB0, 0x05},
	{0xAE, 0x04}, {0xAC, 0x04}, {0xA6, 0x04}, {0xA4, 0x04},
	{0x9E, 0x04}, {0x9C, 0x03}, {0x9A, 0x03}, {0x98, 0x03},
	{0x96, 0x03}, {0x94, 0x03}, {0x92, 0x03}, {0x90, 0x03},
	{0x8E, 0x02}, {0x8C, 0x02}, {0x8A, 0x03}, {0xD8, 0x02},
	{0xD6, 0x02}, {0x88, 0x00}, {0xCD, 0x77}, {0xCB, 0x73},
	{0xC9, 0x6B}, {0xC7, 0x5D}, {0xC5, 0x50}, {0xC3, 0x36},
	{0xC1, 0x1C}, {0xBF, 0x03}, {0xBD, 0xEA}, {0xBB, 0xD1},
	{0xB9, 0xB8}, {0xB7, 0xA0}, {0xB5, 0x87}, {0xB3, 0x56},
	{0xB1, 0x26}, {0xAF, 0xF5}, {0xAD, 0xC4}, {0xA7, 0x92},
	{0xA5, 0x5F}, {0x9F, 0x29}, {0x9D, 0xE6}, {0x9B, 0xC4},
	{0x99, 0xA2}, {0x97, 0x77}, {0x95, 0x48}, {0x93, 0x2B},
	{0x91, 0x0D}, {0x8F, 0xED}, {0x8D, 0xCD}, {0x8B, 0xB1},
	{0xD9, 0xBD}, {0xD7, 0xB6}, {0x89, 0x00}, {0xFE, 0x60},
	{0x00, 0xCC}, {0x01, 0x00}, {0x02, 0x04}, {0x03, 0x00},
	{0x04, 0x00}, {0x05, 0x07}, {0x06, 0x00}, {0x07, 0x88},
	{0x08, 0x00}, {0x09, 0xCC}, {0x0A, 0x00}, {0x0B, 0x04},
	{0x0C, 0x00}, {0x0D, 0x00}, {0x0E, 0x05}, {0x0F, 0x00},
	{0x10, 0x88}, {0x11, 0x00}, {0x12, 0xCC}, {0x13, 0x0F},
	{0x14, 0xFF}, {0x15, 0x04}, {0x16, 0x00}, {0x17, 0x06},
	{0x18, 0x00}, {0x19, 0x96}, {0x1A, 0x00}, {0x24, 0xCC},
	{0x25, 0x00}, {0x26, 0x02}, {0x27, 0x00}, {0x28, 0x00},
	{0x29, 0x06}, {0x2A, 0x06}, {0x2B, 0x82}, {0x2D, 0x00},
	{0x2F, 0xCC}, {0x30, 0x00}, {0x31, 0x02}, {0x32, 0x00},
	{0x33, 0x00}, {0x34, 0x07}, {0x35, 0x06}, {0x36, 0x82},
	{0x37, 0x00}, {0x38, 0xCC}, {0x39, 0x00}, {0x3A, 0x02},
	{0x3B, 0x00}, {0x3D, 0x00}, {0x3F, 0x07}, {0x40, 0x00},
	{0x41, 0x88}, {0x42, 0x00}, {0x43, 0xCC}, {0x44, 0x00},
	{0x45, 0x02}, {0x46, 0x00}, {0x47, 0x00}, {0x48, 0x06},
	{0x49, 0x02}, {0x4A, 0x8A}, {0x4B, 0x00}, {0x5F, 0xCA},
	{0x60, 0x01}, {0x61, 0xE8}, {0x62, 0x09}, {0x63, 0x00},
	{0x64, 0x07}, {0x65, 0x00}, {0x66, 0x30}, {0x67, 0x80},
	{0x9B, 0x03}, {0xA9, 0x07}, {0xAA, 0x06}, {0xAB, 0x02},
	{0xAC, 0x10}, {0xAD, 0x11}, {0xAE, 0x05}, {0xAF, 0x04},
	{0xB0, 0x10}, {0xB1, 0x10}, {0xB2, 0x10}, {0xB3, 0x10},
	{0xB4, 0x10}, {0xB5, 0x10}, {0xB6, 0x10}, {0xB7, 0x10},
	{0xB8, 0x10}, {0xB9, 0x10}, {0xBA, 0x04}, {0xBB, 0x05},
	{0xBC, 0x00}, {0xBD, 0x01}, {0xBE, 0x0A}, {0xBF, 0x10},
	{0xC0, 0x11}, {0xFE, 0xA0}, {0x22, 0x00},
};

struct rad_panel {
	struct mipi_dsi_device *dsi;

	struct gpio_desc reset;

	bool prepared;
	bool enabled;

	unsigned long mode_flags;
	unsigned int lanes;
	u16 dft_brightness;
};

static int rad_panel_push_cmd_list(struct mipi_dsi_device *dsi,
				   struct cmd_set_entry const *cmd_set,
				   size_t count)
{
	size_t i;
	int ret = 0;

	for (i = 0; i < count; i++) {
		const struct cmd_set_entry *entry = cmd_set++;
		u8 buffer[2] = { entry->cmd, entry->param };

		ret = mipi_dsi_generic_write(dsi, &buffer, sizeof(buffer));
		if (ret < 0)
			return ret;
	}

	return ret;
};

static void rad_panel_prepare(struct rockchip_panel *panel)
{
	struct rad_panel *rad = dev_get_priv(panel->dev);
	struct mipi_dsi_device *dsi = dev_get_parent_platdata(panel->dev);
	u8 dsi_mode;
	int ret;

	if (rad->prepared)
		return;

	dsi->lanes = rad->lanes;
	dsi->mode_flags = rad->mode_flags;

	/* At lest 10ms needed between power-on and reset-out as RM specifies */
	mdelay(12);

	if (dm_gpio_is_valid(&rad->reset)) {
		dm_gpio_set_value(&rad->reset, 0);

		/*
		 * 50ms delay after reset-out, as per manufacturer initalization
		 * sequence.
		 */
		mdelay(50);
	}

	dsi->mode_flags |= MIPI_DSI_MODE_LPM;

	ret = rad_panel_push_cmd_list(dsi,
				      &mcs_zh055oe[0],
				      ARRAY_SIZE(mcs_zh055oe));
	if (ret < 0) {
		printf("%s: Failed to send MCS (%d)\n", __func__, ret);
		goto fail;
	}

	/* Select User Command Set table (CMD1) */
	ret = mipi_dsi_generic_write(dsi, (u8[]){ WRMAUCCTR, 0x00 }, 2);
	if (ret < 0)
		goto fail;

	dsi_mode = (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) ? 0x0B : 0x00;
	ret = mipi_dsi_generic_write(dsi, (u8[]){ 0xC2, dsi_mode }, 2);
	if (ret < 0) {
		printf("%s: Failed to set DSI mode (%d)\n", __func__, ret);
		goto fail;
	}
	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
	if (ret < 0) {
		printf("%s: Failed to set tear ON (%d)\n", __func__, ret);
		goto fail;
	}
	ret = mipi_dsi_dcs_set_tear_scanline(dsi, 0x00);
	if (ret < 0) {
		printf("%s: Failed to set tear scanline (%d)\n", __func__, ret);
		goto fail;
	}
	ret = mipi_dsi_dcs_set_pixel_format(dsi, COL_FMT_24BPP);
	if (ret < 0) {
		printf("%s: Failed to set pixel format (%d)\n", __func__, ret);
		goto fail;
	}

	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
	if (ret < 0) {
		printf("%s: Failed to exit sleep mode (%d)\n", __func__, ret);
		goto fail;
	}

	/*
	 * Although, 120ms seems a lot, this is the amount of delay that the
	 * manufacturer suggests it should be used between the sleep-out and
	 * display-on commands
	 */
	mdelay(120);

	ret = mipi_dsi_dcs_set_display_on(dsi);
	if (ret < 0) {
		printf("%s: Failed to set display ON (%d)\n", __func__, ret);
		goto fail;
	}

	/*
	 * Also, 100ms delay between display-on and backlight enable as per
	 * manufacturer initialization sequence.
	 */
	mdelay(100);

	mipi_dsi_dcs_set_display_brightness(dsi, rad->dft_brightness);

	rad->prepared = true;
	return;

fail:
	if (dm_gpio_is_valid(&rad->reset))
		dm_gpio_set_value(&rad->reset, 1);
}

static void rad_panel_unprepare(struct rockchip_panel *panel)
{
	struct rad_panel *rad = dev_get_priv(panel->dev);

	if (!rad->prepared)
		return;

	/*
	 * Right after asserting the reset, we need to release it, so that the
	 * touch driver can have an active connection with the touch controller
	 * even after the display is turned off.
	 */
	if (dm_gpio_is_valid(&rad->reset)) {
		dm_gpio_set_value(&rad->reset, 1);
		mdelay(17);
		dm_gpio_set_value(&rad->reset, 0);
	}

	rad->prepared = false;
}

static void rad_panel_enable(struct rockchip_panel *panel)
{
	struct rad_panel *rad = dev_get_priv(panel->dev);

	if (rad->enabled)
		return;

	rad->enabled = true;
}

static void rad_panel_disable(struct rockchip_panel *panel)
{
	struct rad_panel *rad = dev_get_priv(panel->dev);
	struct mipi_dsi_device *dsi = dev_get_parent_platdata(panel->dev);
	int ret;

	if (!rad->enabled)
		return;

	dsi->mode_flags |= MIPI_DSI_MODE_LPM;

	mipi_dsi_dcs_set_display_brightness(dsi, 0);

	mdelay(12);

	ret = mipi_dsi_dcs_set_display_off(dsi);
	if (ret < 0) {
		printf("%s: Failed to set display OFF (%d)\n", __func__, ret);
		return;
	}

	mdelay(10);

	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
	if (ret < 0) {
		printf("%s: Failed to enter sleep mode (%d)\n", __func__, ret);
		return;
	}

	rad->enabled = false;
}

static const struct rockchip_panel_funcs rad_panel_funcs = {
	.prepare = rad_panel_prepare,
	.unprepare = rad_panel_unprepare,
	.enable = rad_panel_enable,
	.disable = rad_panel_disable,
};

static int rad_panel_probe(struct udevice *dev)
{
	struct rad_panel *rad = dev_get_priv(dev);
	struct rockchip_panel *panel;
	int ret;
	u32 video_mode;

	rad->dft_brightness = 255;
	rad->mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_EOT_PACKET;

	video_mode = dev_read_u32_default(dev, "video-mode", 0);
	switch (video_mode) {
	case 0:
		/* burst mode */
		rad->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST |
				   MIPI_DSI_MODE_VIDEO;
		break;
	case 1:
		/* non-burst mode with sync event */
		rad->mode_flags |= MIPI_DSI_MODE_VIDEO;
		break;
	case 2:
		/* non-burst mode with sync pulse */
		rad->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
				   MIPI_DSI_MODE_VIDEO;
		break;
	case 3:
		/* command mode */
		rad->mode_flags |= MIPI_DSI_CLOCK_NON_CONTINUOUS |
				   MIPI_DSI_MODE_VSYNC_FLUSH;
		break;
	default:
		printf("%s: invalid video mode %d\n", __func__, video_mode);
		break;
	}

	rad->lanes = dev_read_u32_default(dev, "dsi-lanes", 4);

	ret = gpio_request_by_name(dev, "reset-gpios", 0,
				   &rad->reset, GPIOD_IS_OUT);
	if (ret && ret != -ENOENT) {
		printf("%s: Failed to get reset gpio (%d)\n", __func__, ret);
		return ret;
	}
	if (dm_gpio_is_valid(&rad->reset))
		dm_gpio_set_value(&rad->reset, 1);

	panel = calloc(1, sizeof(*panel));
	if (!panel)
		return -ENOMEM;

	dev->driver_data = (ulong)panel;
	panel->dev = dev;
	panel->bus_format = MEDIA_BUS_FMT_RBG888_1X24;
	panel->bpc = 8;
	panel->funcs = &rad_panel_funcs;

	return 0;
}

static const struct udevice_id rad_panel_ids[] = {
	{ .compatible = "raydium,rm67199", },
	{ .compatible = "zhot,zh055oe041", },
	{}
};

U_BOOT_DRIVER(rad_panel) = {
	.name = "panel-raydium-rm67199",
	.id = UCLASS_PANEL,
	.of_match = rad_panel_ids,
	.probe = rad_panel_probe,
	.priv_auto_alloc_size = sizeof(struct rad_panel),
};

MODULE_AUTHOR("Robert Chiras <robert.chiras@nxp.com>");
MODULE_DESCRIPTION("DRM Driver for Raydium RM67191 MIPI DSI panel");
MODULE_LICENSE("GPL v2");
